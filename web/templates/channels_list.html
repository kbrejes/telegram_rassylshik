<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Job Notification Bot</title>
    <link rel="stylesheet" href="/static/style.css">
    <style>
        .channel-card {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: box-shadow 0.2s;
        }

        .channel-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .channel-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .channel-card-header h3 {
            margin: 0;
            font-size: 1.25rem;
        }

        .channel-card-actions {
            display: flex;
            gap: 8px;
        }

        .agents-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .agent-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
        }

        .agent-badge .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .agent-badge .dot.connected {
            background: #4caf50;
            box-shadow: 0 0 6px rgba(76, 175, 80, 0.5);
        }

        .agent-badge .dot.disconnected {
            background: #9e9e9e;
        }

        .agent-badge .dot.flood_wait {
            background: #ff9800;
            box-shadow: 0 0 6px rgba(255, 152, 0, 0.5);
        }

        .agent-badge .dot.error {
            background: #f44336;
            box-shadow: 0 0 6px rgba(244, 67, 54, 0.5);
        }

        .no-agents {
            color: #999;
            font-size: 0.9rem;
        }

        /* Toggle switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #4caf50;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .channel-card.disabled {
            border-left: 4px solid #ccc;
        }

        .channel-card.disabled h3 {
            color: #999;
        }

        .channel-card:not(.disabled) {
            border-left: 4px solid #4caf50;
        }

        .bot-status-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .bot-status-bar .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .bot-status-bar .dot.online {
            background: #4caf50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }

        .bot-status-bar .dot.offline {
            background: #f44336;
        }

        .bot-status-bar .info {
            flex: 1;
        }

        .bot-status-bar .info strong {
            display: block;
        }

        .bot-status-bar .info small {
            color: #666;
        }

        /* Mini vacancy dashboard */
        .vacancy-peek {
            margin-top: 15px;
            border-top: 1px solid #eee;
            padding-top: 12px;
        }

        .vacancy-peek-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .vacancy-peek-header h4 {
            margin: 0;
            font-size: 0.85rem;
            color: #666;
            font-weight: 500;
        }

        .vacancy-peek-header a {
            font-size: 0.75rem;
            color: #1976d2;
            text-decoration: none;
        }

        .vacancy-peek-header a:hover {
            text-decoration: underline;
        }

        .vacancy-mini-table {
            width: 100%;
            font-size: 0.8rem;
            border-collapse: collapse;
        }

        .vacancy-mini-table th {
            text-align: left;
            padding: 4px 8px;
            background: #f8f9fa;
            color: #666;
            font-weight: 500;
            border-bottom: 1px solid #eee;
        }

        .vacancy-mini-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #f0f0f0;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .vacancy-mini-table tr:last-child td {
            border-bottom: none;
        }

        .vacancy-mini-table .status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .vacancy-mini-table .status-badge.passed {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .vacancy-mini-table .status-badge.filtered {
            background: #ffebee;
            color: #c62828;
        }

        .vacancy-peek-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 8px;
        }

        .vacancy-peek-stat {
            font-size: 0.75rem;
            color: #666;
        }

        .vacancy-peek-stat .num {
            font-weight: 600;
            color: #333;
        }

        .vacancy-peek-stat.passed .num {
            color: #4caf50;
        }

        .vacancy-peek-stat.filtered .num {
            color: #f44336;
        }

        .vacancy-peek-empty {
            color: #999;
            font-size: 0.8rem;
            text-align: center;
            padding: 10px;
        }

        .vacancy-peek-content {
            max-height: 150px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Job Notification Bot</h1>
            <nav class="nav-menu">
                <a href="/" class="active">Channels</a>
                <a href="/agents">Agents</a>
                <a href="/vacancy-log">Vacancy Log</a>
                <a href="/candidate">Candidate</a>
                <a href="/ai-stats">AI Stats</a>
                <a href="/auth">Bot Auth</a>
            </nav>
        </div>

        <!-- Bot Status Bar -->
        <div class="bot-status-bar" id="bot-status-bar">
            <span class="dot offline" id="bot-dot"></span>
            <div class="info">
                <strong id="bot-name">Bot</strong>
                <small id="bot-info">Checking...</small>
            </div>
            <a href="/status" class="button button-small button-secondary">Manage</a>
        </div>

        <div class="card">
            <div class="channels-header">
                <h2>Channels</h2>
                <a href="/channel/new" class="button button-primary">+ Add Channel</a>
            </div>

            {% if channels %}
                <div class="channels-list">
                    {% for channel in channels %}
                    <div class="channel-card{% if not channel.enabled %} disabled{% endif %}" data-channel-id="{{ channel.id }}">
                        <div class="channel-card-header">
                            <h3>{{ channel.name }}</h3>
                            <div class="channel-card-actions">
                                <label class="toggle-switch" title="{% if channel.enabled %}Enabled{% else %}Disabled{% endif %}">
                                    <input type="checkbox" {% if channel.enabled %}checked{% endif %} onchange="toggleChannel('{{ channel.id }}', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                                <a href="/channel/{{ channel.id }}" class="button button-secondary button-small">Edit</a>
                                <button onclick="deleteChannel('{{ channel.id }}')" class="button button-danger button-small">Delete</button>
                            </div>
                        </div>

                        <div class="agents-row" id="agents-{{ channel.id }}">
                            {% if channel.agents %}
                                {% for agent in channel.agents %}
                                <div class="agent-badge" data-session="{{ agent.session_name }}">
                                    <span class="dot disconnected"></span>
                                    <span class="name">{{ agent.session_name }}</span>
                                </div>
                                {% endfor %}
                            {% else %}
                                <span class="no-agents">No agents configured</span>
                            {% endif %}
                        </div>

                        <!-- Mini Vacancy Dashboard -->
                        <div class="vacancy-peek" id="vacancy-peek-{{ channel.id }}">
                            <div class="vacancy-peek-header">
                                <h4>Recent Vacancies</h4>
                                <a href="/vacancy-log">View all â†’</a>
                            </div>
                            <div class="vacancy-peek-stats" id="vacancy-stats-{{ channel.id }}">
                                <span class="vacancy-peek-stat">Total: <span class="num">-</span></span>
                                <span class="vacancy-peek-stat passed">Passed: <span class="num">-</span></span>
                                <span class="vacancy-peek-stat filtered">Filtered: <span class="num">-</span></span>
                            </div>
                            <div class="vacancy-peek-content" id="vacancy-content-{{ channel.id }}">
                                <div class="vacancy-peek-empty">Loading...</div>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            {% else %}
                <div class="empty-state">
                    <div class="empty-state-icon">ðŸ“­</div>
                    <h3>No channels yet</h3>
                    <p>Create your first channel</p>
                    <a href="/channel/new" class="button button-primary" style="margin-top: 1rem;">
                        Create Channel
                    </a>
                </div>
            {% endif %}
        </div>
    </div>

    <script>
        // Load status and update UI
        async function loadStatus() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();

                if (data.success) {
                    // Update bot status bar
                    const bot = data.status.bot;
                    const botDot = document.getElementById('bot-dot');
                    const botName = document.getElementById('bot-name');
                    const botInfo = document.getElementById('bot-info');

                    if (bot.connected && bot.authorized) {
                        botDot.className = 'dot online';
                        if (bot.user_info) {
                            botName.textContent = bot.user_info.first_name || 'Bot';
                            botInfo.textContent = '@' + (bot.user_info.username || 'connected');
                        } else {
                            botName.textContent = 'Bot';
                            botInfo.textContent = 'Connected';
                        }
                    } else {
                        botDot.className = 'dot offline';
                        botName.textContent = 'Bot';
                        botInfo.textContent = 'Offline';
                    }

                    // Update agent statuses
                    const agents = data.status.agents || {};
                    document.querySelectorAll('.agent-badge').forEach(badge => {
                        const sessionName = badge.dataset.session;
                        const agentStatus = agents[sessionName];
                        const dot = badge.querySelector('.dot');
                        const nameSpan = badge.querySelector('.name');

                        if (agentStatus) {
                            dot.className = 'dot ' + (agentStatus.status || 'disconnected');

                            // Update name with user info if available
                            if (agentStatus.user_info) {
                                const name = agentStatus.user_info.first_name || sessionName;
                                const username = agentStatus.user_info.username;
                                nameSpan.textContent = username ? `${name} (@${username})` : name;
                            }
                        } else {
                            dot.className = 'dot disconnected';
                        }
                    });
                }
            } catch (error) {
                console.error('Error loading status:', error);
            }
        }

        // Toggle channel enabled/disabled
        async function toggleChannel(channelId, enabled) {
            try {
                const response = await fetch(`/api/channels/${channelId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: enabled })
                });

                const data = await response.json();

                if (data.success) {
                    const card = document.querySelector(`.channel-card[data-channel-id="${channelId}"]`);
                    const toggle = card.querySelector('.toggle-switch');
                    if (enabled) {
                        card.classList.remove('disabled');
                        toggle.title = 'Enabled';
                    } else {
                        card.classList.add('disabled');
                        toggle.title = 'Disabled';
                    }
                } else {
                    alert('Error: ' + (data.message || 'Failed to update channel'));
                    // Revert toggle state
                    const checkbox = document.querySelector(`.channel-card[data-channel-id="${channelId}"] input[type="checkbox"]`);
                    checkbox.checked = !enabled;
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error updating channel');
                // Revert toggle state
                const checkbox = document.querySelector(`.channel-card[data-channel-id="${channelId}"] input[type="checkbox"]`);
                checkbox.checked = !enabled;
            }
        }

        // Delete channel
        async function deleteChannel(channelId) {
            const deleteConfig = confirm('Delete this channel configuration?');
            if (!deleteConfig) {
                return;
            }

            // Ask if user also wants to delete Telegram entities (channel + CRM group)
            const deleteTelegram = confirm('Also delete the Telegram channel and CRM group?\n\nClick OK to delete everything.\nClick Cancel to keep Telegram entities.');

            try {
                const response = await fetch(`/api/channels/${channelId}?delete_telegram=${deleteTelegram}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    let msg = 'Channel deleted!';
                    if (data.deleted && data.deleted.length > 0) {
                        msg += '\n\nDeleted: ' + data.deleted.join(', ');
                    }
                    if (data.pending && data.pending.length > 0) {
                        msg += '\n\nPending (rate limited): ' + data.pending.join(', ');
                    }
                    if (data.errors && data.errors.length > 0) {
                        msg += '\n\nErrors: ' + data.errors.join(', ');
                    }
                    alert(msg);
                    window.location.reload();
                } else {
                    alert('Error: ' + (data.message || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error deleting channel');
            }
        }

        // Load vacancy peek data
        async function loadVacancyPeek() {
            try {
                const response = await fetch('/api/vacancies/log?limit=50');
                const data = await response.json();

                if (data.success) {
                    // Update all channel cards with the same global data
                    document.querySelectorAll('.vacancy-peek').forEach(peek => {
                        const channelId = peek.id.replace('vacancy-peek-', '');
                        const statsContainer = document.getElementById(`vacancy-stats-${channelId}`);
                        const contentContainer = document.getElementById(`vacancy-content-${channelId}`);

                        // Update stats
                        const stats = data.stats;
                        statsContainer.innerHTML = `
                            <span class="vacancy-peek-stat">Total: <span class="num">${stats.total}</span></span>
                            <span class="vacancy-peek-stat passed">Passed: <span class="num">${stats.passed}</span></span>
                            <span class="vacancy-peek-stat filtered">Filtered: <span class="num">${stats.filtered}</span></span>
                        `;

                        // Update table
                        if (data.vacancies.length === 0) {
                            contentContainer.innerHTML = '<div class="vacancy-peek-empty">No vacancies yet</div>';
                        } else {
                            let html = `
                                <table class="vacancy-mini-table">
                                    <thead>
                                        <tr>
                                            <th>Source</th>
                                            <th>Status</th>
                                            <th>Time</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                            `;

                            data.vacancies.forEach(v => {
                                const status = v.is_relevant ? 'passed' : 'filtered';
                                const statusLabel = v.is_relevant ? 'Passed' : 'Filtered';
                                const time = formatTime(v.processed_at);
                                const source = v.chat_title || 'Unknown';

                                html += `
                                    <tr>
                                        <td title="${source}">${source}</td>
                                        <td><span class="status-badge ${status}">${statusLabel}</span></td>
                                        <td>${time}</td>
                                    </tr>
                                `;
                            });

                            html += '</tbody></table>';
                            contentContainer.innerHTML = html;
                        }
                    });
                }
            } catch (error) {
                console.error('Error loading vacancy peek:', error);
            }
        }

        function formatTime(dateStr) {
            if (!dateStr) return '-';
            const date = new Date(dateStr + 'Z');
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        // Load on page load and refresh every 5 seconds
        loadStatus();
        loadVacancyPeek();
        setInterval(loadStatus, 5000);
        setInterval(loadVacancyPeek, 30000);  // Refresh vacancies every 30s
    </script>
</body>
</html>
