<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Job Notification Bot</title>
    <link rel="stylesheet" href="/static/style.css">
    <style>
        .channel-card {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: box-shadow 0.2s;
        }

        .channel-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .channel-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .channel-card-header h3 {
            margin: 0;
            font-size: 1.25rem;
        }

        .channel-card-actions {
            display: flex;
            gap: 8px;
        }

        .agents-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .agent-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
        }

        .agent-badge .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .agent-badge .dot.connected {
            background: #4caf50;
            box-shadow: 0 0 6px rgba(76, 175, 80, 0.5);
        }

        .agent-badge .dot.disconnected {
            background: #9e9e9e;
        }

        .agent-badge .dot.flood_wait {
            background: #ff9800;
            box-shadow: 0 0 6px rgba(255, 152, 0, 0.5);
        }

        .agent-badge .dot.error {
            background: #f44336;
            box-shadow: 0 0 6px rgba(244, 67, 54, 0.5);
        }

        .no-agents {
            color: #999;
            font-size: 0.9rem;
        }

        /* Toggle switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #4caf50;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .channel-card.disabled {
            border-left: 4px solid #ccc;
        }

        .channel-card.disabled h3 {
            color: #999;
        }

        .channel-card:not(.disabled) {
            border-left: 4px solid #4caf50;
        }

        .bot-status-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .bot-status-bar .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .bot-status-bar .dot.online {
            background: #4caf50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }

        .bot-status-bar .dot.offline {
            background: #f44336;
        }

        .bot-status-bar .info {
            flex: 1;
        }

        .bot-status-bar .info strong {
            display: block;
        }

        .bot-status-bar .info small {
            color: #666;
        }

        /* Mini vacancy dashboard */
        .vacancy-peek {
            margin-top: 15px;
            border-top: 1px solid #eee;
            padding-top: 12px;
        }

        .vacancy-peek-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .vacancy-peek-header h4 {
            margin: 0;
            font-size: 0.85rem;
            color: #666;
            font-weight: 500;
        }

        .vacancy-peek-header a {
            font-size: 0.75rem;
            color: #1976d2;
            text-decoration: none;
        }

        .vacancy-peek-header a:hover {
            text-decoration: underline;
        }

        .vacancy-mini-table {
            width: 100%;
            font-size: 0.8rem;
            border-collapse: collapse;
        }

        .vacancy-mini-table th {
            text-align: left;
            padding: 4px 8px;
            background: #f8f9fa;
            color: #666;
            font-weight: 500;
            border-bottom: 1px solid #eee;
        }

        .vacancy-mini-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #f0f0f0;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .vacancy-mini-table tr:last-child td {
            border-bottom: none;
        }

        .vacancy-mini-table .status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .vacancy-mini-table .status-badge.passed {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .vacancy-mini-table .status-badge.filtered {
            background: #ffebee;
            color: #c62828;
        }

        .msg-led {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-left: 6px;
            vertical-align: middle;
            flex-shrink: 0;
        }

        .msg-led.has-messages {
            background: #2196f3;
        }

        .msg-led.no-messages {
            background: #ccc;
        }

        .vacancy-mini-table td:nth-child(2) {
            text-align: right;
            white-space: nowrap;
        }

        .vacancy-peek-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 8px;
        }

        .vacancy-peek-stat {
            font-size: 0.75rem;
            color: #666;
        }

        .vacancy-peek-stat .num {
            font-weight: 600;
            color: #333;
        }

        .vacancy-peek-stat.passed .num {
            color: #4caf50;
        }

        .vacancy-peek-stat.filtered .num {
            color: #f44336;
        }

        .vacancy-peek-empty {
            color: #999;
            font-size: 0.8rem;
            text-align: center;
            padding: 10px;
        }

        .vacancy-sort-controls {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }

        .sort-btn {
            padding: 2px 8px;
            font-size: 0.7rem;
            border: 1px solid #ddd;
            background: #fff;
            border-radius: 4px;
            cursor: pointer;
            color: #666;
        }

        .sort-btn:hover {
            background: #f5f5f5;
        }

        .sort-btn.active {
            background: #e3f2fd;
            border-color: #2196f3;
            color: #1976d2;
        }

        .vacancy-peek-content {
            max-height: 150px;
            overflow-y: auto;
        }

        .vacancy-mini-table tr {
            cursor: pointer;
            transition: background 0.15s;
        }

        .vacancy-mini-table tr:hover {
            background: #f0f7ff;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 12px;
            max-width: 600px;
            max-height: 80vh;
            width: 90%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.1rem;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            line-height: 1;
        }

        .modal-close:hover {
            color: #333;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-field {
            margin-bottom: 15px;
        }

        .modal-field-label {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }

        .modal-field-value {
            color: #555;
            font-size: 0.9rem;
        }

        .modal-full-text {
            background: #f5f5f5;
            padding: 12px;
            border-radius: 5px;
            max-height: 250px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        /* Message log */
        .message-log {
            margin-top: 15px;
            border-top: 1px solid #eee;
            padding-top: 15px;
        }

        .message-log-header {
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }

        .message-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 350px;
            overflow-y: auto;
        }

        .message-item {
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            max-width: 85%;
        }

        .message-item.outgoing {
            background: #e3f2fd;
            color: #1565c0;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        .message-item.incoming {
            background: #f5f5f5;
            color: #333;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }

        .message-item .time {
            font-size: 0.7rem;
            color: #999;
            margin-top: 4px;
        }

        .message-item.outgoing .time {
            text-align: right;
        }

        .message-sender {
            font-weight: 600;
            font-size: 0.75rem;
            margin-bottom: 3px;
            opacity: 0.7;
        }

        .message-text {
            white-space: pre-wrap;
            word-break: break-word;
        }

        .no-messages {
            color: #999;
            font-size: 0.85rem;
            text-align: center;
            padding: 15px;
        }

        .bot-interaction-header {
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 0.8rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bot-interaction-header .bot-name {
            font-weight: 600;
            color: #1976d2;
        }

        .bot-interaction-header .status {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .bot-interaction-header .status.success {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .bot-interaction-header .status.failed {
            background: #ffebee;
            color: #c62828;
        }

        .bot-interaction-header .status.in_progress {
            background: #fff3e0;
            color: #ef6c00;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Job Notification Bot</h1>
            <nav class="nav-menu">
                <a href="/" class="active">Channels</a>
                <a href="/agents">Agents</a>
                <a href="/vacancy-log">Vacancy Log</a>
                <a href="/candidate">Candidate</a>
                <a href="/ai-stats">AI Stats</a>
                <a href="/auth">Bot Auth</a>
            </nav>
        </div>

        <!-- Bot Status Bar -->
        <div class="bot-status-bar" id="bot-status-bar">
            <span class="dot offline" id="bot-dot"></span>
            <div class="info">
                <strong id="bot-name">Bot</strong>
                <small id="bot-info">Checking...</small>
            </div>
            <a href="/status" class="button button-small button-secondary">Manage</a>
        </div>

        <div class="card">
            <div class="channels-header">
                <h2>Channels</h2>
                <a href="/channel/new" class="button button-primary">+ Add Channel</a>
            </div>

            {% if channels %}
                <div class="channels-list">
                    {% for channel in channels %}
                    <div class="channel-card{% if not channel.enabled %} disabled{% endif %}" data-channel-id="{{ channel.id }}">
                        <div class="channel-card-header">
                            <h3>{{ channel.name }}</h3>
                            <div class="channel-card-actions">
                                <label class="toggle-switch" title="{% if channel.enabled %}Enabled{% else %}Disabled{% endif %}">
                                    <input type="checkbox" {% if channel.enabled %}checked{% endif %} onchange="toggleChannel('{{ channel.id }}', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                                <a href="/channel/{{ channel.id }}" class="button button-secondary button-small">Edit</a>
                                <button onclick="deleteChannel('{{ channel.id }}')" class="button button-danger button-small">Delete</button>
                            </div>
                        </div>

                        <div class="agents-row" id="agents-{{ channel.id }}">
                            {% if channel.agents %}
                                {% for agent in channel.agents %}
                                <div class="agent-badge" data-session="{{ agent.session_name }}">
                                    <span class="dot disconnected"></span>
                                    <span class="name">{{ agent.session_name }}</span>
                                </div>
                                {% endfor %}
                            {% else %}
                                <span class="no-agents">No agents configured</span>
                            {% endif %}
                        </div>

                        <!-- Mini Vacancy Dashboard -->
                        <div class="vacancy-peek" id="vacancy-peek-{{ channel.id }}">
                            <div class="vacancy-peek-header">
                                <h4>Recent Vacancies</h4>
                                <div class="vacancy-sort-controls">
                                    <button class="sort-btn active" onclick="sortVacancies('latest')" id="sort-latest">Latest</button>
                                    <button class="sort-btn" onclick="sortVacancies('messages')" id="sort-messages">Has msgs</button>
                                </div>
                                <a href="/vacancy-log">View all â†’</a>
                            </div>
                            <div class="vacancy-peek-stats" id="vacancy-stats-{{ channel.id }}">
                                <span class="vacancy-peek-stat">Total: <span class="num">-</span></span>
                                <span class="vacancy-peek-stat passed">Passed: <span class="num">-</span></span>
                                <span class="vacancy-peek-stat filtered">Filtered: <span class="num">-</span></span>
                            </div>
                            <div class="vacancy-peek-content" id="vacancy-content-{{ channel.id }}">
                                <div class="vacancy-peek-empty">Loading...</div>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            {% else %}
                <div class="empty-state">
                    <div class="empty-state-icon">ðŸ“­</div>
                    <h3>No channels yet</h3>
                    <p>Create your first channel</p>
                    <a href="/channel/new" class="button button-primary" style="margin-top: 1rem;">
                        Create Channel
                    </a>
                </div>
            {% endif %}
        </div>
    </div>

    <!-- Vacancy Detail Modal -->
    <div class="modal-overlay" id="modal-overlay" onclick="closeModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3>Vacancy Details</h3>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body" id="modal-body">
            </div>
        </div>
    </div>

    <script>
        let peekVacancies = [];  // Store vacancies for modal
        let currentSort = 'latest';  // Current sort order

        // Load status and update UI
        async function loadStatus() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();

                if (data.success) {
                    // Update bot status bar
                    const bot = data.status.bot;
                    const botDot = document.getElementById('bot-dot');
                    const botName = document.getElementById('bot-name');
                    const botInfo = document.getElementById('bot-info');

                    if (bot.connected && bot.authorized) {
                        botDot.className = 'dot online';
                        if (bot.user_info) {
                            botName.textContent = bot.user_info.first_name || 'Bot';
                            botInfo.textContent = '@' + (bot.user_info.username || 'connected');
                        } else {
                            botName.textContent = 'Bot';
                            botInfo.textContent = 'Connected';
                        }
                    } else {
                        botDot.className = 'dot offline';
                        botName.textContent = 'Bot';
                        botInfo.textContent = 'Offline';
                    }

                    // Update agent statuses
                    const agents = data.status.agents || {};
                    document.querySelectorAll('.agent-badge').forEach(badge => {
                        const sessionName = badge.dataset.session;
                        const agentStatus = agents[sessionName];
                        const dot = badge.querySelector('.dot');
                        const nameSpan = badge.querySelector('.name');

                        if (agentStatus) {
                            dot.className = 'dot ' + (agentStatus.status || 'disconnected');

                            // Update name with user info if available
                            if (agentStatus.user_info) {
                                const name = agentStatus.user_info.first_name || sessionName;
                                const username = agentStatus.user_info.username;
                                nameSpan.textContent = username ? `${name} (@${username})` : name;
                            }
                        } else {
                            dot.className = 'dot disconnected';
                        }
                    });
                }
            } catch (error) {
                console.error('Error loading status:', error);
            }
        }

        // Toggle channel enabled/disabled
        async function toggleChannel(channelId, enabled) {
            try {
                const response = await fetch(`/api/channels/${channelId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: enabled })
                });

                const data = await response.json();

                if (data.success) {
                    const card = document.querySelector(`.channel-card[data-channel-id="${channelId}"]`);
                    const toggle = card.querySelector('.toggle-switch');
                    if (enabled) {
                        card.classList.remove('disabled');
                        toggle.title = 'Enabled';
                    } else {
                        card.classList.add('disabled');
                        toggle.title = 'Disabled';
                    }
                } else {
                    alert('Error: ' + (data.message || 'Failed to update channel'));
                    // Revert toggle state
                    const checkbox = document.querySelector(`.channel-card[data-channel-id="${channelId}"] input[type="checkbox"]`);
                    checkbox.checked = !enabled;
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error updating channel');
                // Revert toggle state
                const checkbox = document.querySelector(`.channel-card[data-channel-id="${channelId}"] input[type="checkbox"]`);
                checkbox.checked = !enabled;
            }
        }

        // Delete channel
        async function deleteChannel(channelId) {
            const deleteConfig = confirm('Delete this channel configuration?');
            if (!deleteConfig) {
                return;
            }

            // Ask if user also wants to delete Telegram entities (channel + CRM group)
            const deleteTelegram = confirm('Also delete the Telegram channel and CRM group?\n\nClick OK to delete everything.\nClick Cancel to keep Telegram entities.');

            try {
                const response = await fetch(`/api/channels/${channelId}?delete_telegram=${deleteTelegram}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    let msg = 'Channel deleted!';
                    if (data.deleted && data.deleted.length > 0) {
                        msg += '\n\nDeleted: ' + data.deleted.join(', ');
                    }
                    if (data.pending && data.pending.length > 0) {
                        msg += '\n\nPending (rate limited): ' + data.pending.join(', ');
                    }
                    if (data.errors && data.errors.length > 0) {
                        msg += '\n\nErrors: ' + data.errors.join(', ');
                    }
                    alert(msg);
                    window.location.reload();
                } else {
                    alert('Error: ' + (data.message || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error deleting channel');
            }
        }

        // Load vacancy peek data
        let allVacancies = [];  // Original unsorted vacancies
        let vacancyStats = null;

        async function loadVacancyPeek() {
            try {
                const response = await fetch('/api/vacancies/log?limit=50');
                const data = await response.json();

                if (data.success) {
                    allVacancies = data.vacancies;
                    vacancyStats = data.stats;
                    renderVacancies();
                }
            } catch (error) {
                console.error('Error loading vacancy peek:', error);
            }
        }

        function sortVacancies(sortBy) {
            currentSort = sortBy;

            // Update button states
            document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`sort-${sortBy}`).classList.add('active');

            renderVacancies();
        }

        function renderVacancies() {
            // Sort vacancies based on current sort
            let sorted = [...allVacancies];
            if (currentSort === 'messages') {
                // Sort by has_messages (true first), then by date
                sorted.sort((a, b) => {
                    if (a.has_messages === b.has_messages) {
                        return new Date(b.processed_at) - new Date(a.processed_at);
                    }
                    return b.has_messages - a.has_messages;
                });
            } else {
                // Sort by latest (default - already sorted by API)
                sorted.sort((a, b) => new Date(b.processed_at) - new Date(a.processed_at));
            }

            peekVacancies = sorted;  // Store for modal

            // Update all channel cards with the same global data
            document.querySelectorAll('.vacancy-peek').forEach(peek => {
                const channelId = peek.id.replace('vacancy-peek-', '');
                const statsContainer = document.getElementById(`vacancy-stats-${channelId}`);
                const contentContainer = document.getElementById(`vacancy-content-${channelId}`);

                // Update stats
                if (vacancyStats) {
                    statsContainer.innerHTML = `
                        <span class="vacancy-peek-stat">Total: <span class="num">${vacancyStats.total}</span></span>
                        <span class="vacancy-peek-stat passed">Passed: <span class="num">${vacancyStats.passed}</span></span>
                        <span class="vacancy-peek-stat filtered">Filtered: <span class="num">${vacancyStats.filtered}</span></span>
                    `;
                }

                // Update table
                if (sorted.length === 0) {
                    contentContainer.innerHTML = '<div class="vacancy-peek-empty">No vacancies yet</div>';
                } else {
                    let html = `
                        <table class="vacancy-mini-table">
                            <thead>
                                <tr>
                                    <th>Source</th>
                                    <th>Status</th>
                                    <th>Time</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    sorted.forEach((v, idx) => {
                        const status = v.is_relevant ? 'passed' : 'filtered';
                        const statusLabel = v.is_relevant ? 'Passed' : 'Filtered';
                        const time = formatTime(v.processed_at);
                        const source = v.chat_title || 'Unknown';
                        const ledClass = v.has_messages ? 'has-messages' : 'no-messages';

                        html += `
                            <tr onclick="showVacancyDetails(${idx})">
                                <td title="${source}">${source}</td>
                                <td><span class="status-badge ${status}">${statusLabel}</span><span class="msg-led ${ledClass}"></span></td>
                                <td>${time}</td>
                            </tr>
                        `;
                    });

                    html += '</tbody></table>';
                    contentContainer.innerHTML = html;
                }
            });
        }

        async function showVacancyDetails(idx) {
            const v = peekVacancies[idx];
            if (!v) return;

            const modal = document.getElementById('modal-overlay');
            const body = document.getElementById('modal-body');

            const statusClass = v.is_relevant ? 'passed' : 'filtered';
            const statusLabel = v.is_relevant ? 'Passed' : 'Filtered';

            body.innerHTML = `
                <div class="modal-field">
                    <div class="modal-field-label">Source</div>
                    <div class="modal-field-value">${escapeHtml(v.chat_title || 'Unknown')}</div>
                </div>
                <div class="modal-field">
                    <div class="modal-field-label">Status</div>
                    <div class="modal-field-value">
                        <span class="status-badge ${statusClass}">${statusLabel}</span>
                    </div>
                </div>
                <div class="modal-field">
                    <div class="modal-field-label">AI Reason</div>
                    <div class="modal-field-value">${escapeHtml(v.ai_reason || 'No reason provided')}</div>
                </div>
                <div class="modal-field">
                    <div class="modal-field-label">Processed</div>
                    <div class="modal-field-value">${v.processed_at || '-'}</div>
                </div>
                <div class="message-log" id="message-log">
                    <div class="message-log-header">Message Log</div>
                    <div class="no-messages">Loading...</div>
                </div>
                <div class="modal-field">
                    <div class="modal-field-label">Full Text</div>
                    <div class="modal-full-text">${escapeHtml(v.text_full || v.text_preview || '')}</div>
                </div>
            `;

            modal.classList.add('active');

            // Load conversation data
            try {
                const response = await fetch(`/api/vacancies/messages/${v.id}`);
                const data = await response.json();
                const logContainer = document.getElementById('message-log');

                if (data.success && data.conversations && data.conversations.length > 0) {
                    let html = '<div class="message-log-header">CRM Conversation</div>';

                    data.conversations.forEach(conv => {
                        const phaseClass = conv.call_scheduled ? 'success' :
                                          conv.call_offered ? 'in_progress' : 'in_progress';

                        html += `
                            <div class="bot-interaction-header">
                                <span class="bot-name">${escapeHtml(conv.contact_name || 'Contact')}</span>
                                <span class="status ${phaseClass}">${conv.current_phase}</span>
                            </div>
                        `;

                        // Display actual messages if available
                        if (conv.messages && conv.messages.length > 0) {
                            html += '<div class="message-list">';
                            conv.messages.forEach(msg => {
                                // Skip system messages (original vacancy text)
                                if (msg.role === 'system') return;

                                const msgClass = msg.role === 'assistant' ? 'outgoing' : 'incoming';
                                const sender = msg.role === 'assistant' ? 'Bot' : conv.contact_name || 'Contact';
                                html += `
                                    <div class="message-item ${msgClass}">
                                        <div class="message-sender">${escapeHtml(sender)}</div>
                                        <div class="message-text">${escapeHtml(msg.content || '')}</div>
                                    </div>
                                `;
                            });
                            html += '</div>';
                        } else {
                            html += `
                                <div class="message-list">
                                    <div class="message-item incoming">
                                        <div><strong>Total messages:</strong> ${conv.total_messages}</div>
                                        <div><strong>Call offered:</strong> ${conv.call_offered ? 'Yes' : 'No'}</div>
                                        <div><strong>Call scheduled:</strong> ${conv.call_scheduled ? 'Yes' : 'No'}</div>
                                        ${conv.last_interaction ? `<div class="time">Last: ${new Date(conv.last_interaction).toLocaleString()}</div>` : ''}
                                    </div>
                                </div>
                            `;
                        }
                    });

                    logContainer.innerHTML = html;
                } else {
                    logContainer.innerHTML = `
                        <div class="message-log-header">CRM Conversation</div>
                        <div class="no-messages">No conversation linked to this vacancy yet</div>
                    `;
                }
            } catch (error) {
                console.error('Error loading conversation:', error);
                document.getElementById('message-log').innerHTML = `
                    <div class="message-log-header">CRM Conversation</div>
                    <div class="no-messages">Failed to load conversation</div>
                `;
            }
        }

        function closeModal(event) {
            if (event && event.target !== document.getElementById('modal-overlay')) return;
            document.getElementById('modal-overlay').classList.remove('active');
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatTime(dateStr) {
            if (!dateStr) return '-';
            const date = new Date(dateStr + 'Z');
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        // Load on page load and refresh every 5 seconds
        loadStatus();
        loadVacancyPeek();
        setInterval(loadStatus, 5000);
        setInterval(loadVacancyPeek, 30000);  // Refresh vacancies every 30s
    </script>
</body>
</html>
