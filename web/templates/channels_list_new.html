<!DOCTYPE html>
<html lang="en" class="h-full" x-data="{ darkMode: localStorage.getItem('darkMode') === 'true' }" x-init="$watch('darkMode', val => localStorage.setItem('darkMode', val))" :class="{ 'dark': darkMode }">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Job Notification Bot</title>
    {% include 'partials/design_system.html' %}
    <script src="/static/js/cache.js"></script>
    <!-- Page-specific Tailwind components -->
    <style type="text/tailwindcss">
        @layer components {
            .sort-btn-active {
                @apply bg-white text-gray-900;
            }
            .dark .sort-btn-active {
                @apply bg-dark-600 text-white;
            }
            .sort-btn-inactive {
                @apply text-gray-500;
            }
            .dark .sort-btn-inactive {
                @apply text-gray-400;
            }
        }
        .preload * {
            transition: none !important;
            animation: none !important;
        }
    </style>
    <style>
        /* Tooltip for vacancy peek */
        .peek-icon {
            opacity: 0.5;
            transition: opacity 0.15s;
            flex-shrink: 0;
        }
        .peek-icon:hover, .peek-icon.active {
            opacity: 1;
        }
        /* Status badge should be more visible */
        .peek-icon.status-badge {
            opacity: 0.85;
        }
        .peek-icon.status-badge:hover, .peek-icon.status-badge.active {
            opacity: 1;
            transform: scale(1.05);
        }
        .vacancy-tooltip {
            display: none;
            position: fixed;
            z-index: 200;
            background: #1f2937;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            max-width: min(350px, 90vw);
            white-space: pre-wrap;
            word-break: break-word;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            line-height: 1.5;
            pointer-events: none;
        }
        .vacancy-tooltip.show {
            display: block;
        }
    </style>
    <script>
        // Apply theme immediately to prevent flash
        if (localStorage.getItem('darkMode') === 'true') {
            document.documentElement.classList.add('dark');
        }
    </script>
</head>
<body class="h-full bg-gray-50 dark:bg-dark-950 preload">
    <div class="flex h-full">
        {% include 'partials/sidebar_new.html' %}

        <!-- Main Content -->
        <main class="flex-1 flex flex-col min-h-screen min-w-0 lg:ml-0 overflow-x-hidden">
            <!-- Top Header (Mobile) -->
            <header class="sticky top-0 z-30 flex items-center gap-3 px-3 py-2.5 bg-white dark:bg-dark-800 border-b border-gray-200 dark:border-dark-700 lg:hidden">
                <button onclick="toggleSidebar()" class="p-2 -ml-1 rounded-lg hover:bg-gray-100 dark:hover:bg-dark-700 flex-shrink-0">
                    <svg class="w-5 h-5 text-gray-600 dark:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
                    </svg>
                </button>
                <h1 class="text-base font-semibold text-gray-900 dark:text-white truncate">Channels</h1>
            </header>

            <!-- Page Content -->
            <div class="flex-1 p-4 lg:p-8">
                <!-- Page Header -->
                <div class="flex items-center justify-between mb-6">
                    <h1 class="text-2xl font-bold text-gray-900 dark:text-white hidden lg:block">Channels</h1>
                    <!-- Desktop button -->
                    <a href="/channel/new" class="hidden sm:inline-flex items-center justify-center gap-2 px-4 py-2.5 text-sm font-medium text-white bg-accent rounded-lg hover:bg-accent-hover transition-all shadow-sm hover:shadow-md">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                        </svg>
                        Add Channel
                    </a>
                </div>

                <!-- Mobile FAB -->
                <a href="/channel/new" class="sm:hidden fixed bottom-6 left-6 z-50 w-14 h-14 flex items-center justify-center bg-accent text-white rounded-full shadow-lg hover:bg-accent-hover transition-all">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                    </svg>
                </a>

                <!-- Channels List -->
                {% if channels %}
                <div id="channels-container" class="space-y-4">
                    {% for channel in channels %}
                    <div class="channel-card bg-white dark:bg-dark-800 rounded-xl shadow-sm hover:shadow-md transition-all duration-300 overflow-hidden" data-channel-id="{{ channel.id }}" data-source-titles="{{ channel.source_titles | join('|||') if channel.source_titles else '' }}" draggable="true">
                        <!-- Channel Header -->
                        <div class="flex items-center justify-between p-4 gap-3 border-b border-gray-100 dark:border-dark-700">
                            <div class="flex items-center gap-3 min-w-0">
                                <div class="flex-shrink-0 flex items-center justify-center w-10 h-10 rounded-lg cursor-grab active:cursor-grabbing {% if channel.enabled %}bg-green-100 dark:bg-green-900/30 text-green-600 dark:text-green-400{% else %}bg-gray-100 dark:bg-dark-700 text-gray-400{% endif %}">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"/>
                                    </svg>
                                </div>
                                <div class="min-w-0">
                                    <h3 class="font-semibold text-gray-900 dark:text-white truncate">{{ channel.name }}</h3>
                                    <div class="flex flex-wrap gap-1 mt-1">
                                        <span class="bot-status-indicator inline-flex items-center gap-1 px-2 py-0.5 text-xs rounded-full bg-gray-100 dark:bg-dark-700 text-gray-500 dark:text-gray-400">
                                            <span class="bot-status-dot w-1.5 h-1.5 rounded-full bg-gray-400"></span>
                                            <span class="bot-status-text">...</span>
                                        </span>
                                        <span class="agents-count-indicator inline-flex items-center gap-1 px-2 py-0.5 text-xs rounded-full bg-gray-100 dark:bg-dark-700 text-gray-500 dark:text-gray-400">
                                            <span class="agents-count-text">...</span>
                                        </span>
                                    </div>
                                </div>
                            </div>
                            <div class="flex items-center gap-2 flex-shrink-0">
                                <!-- AI Toggle Switch -->
                                <label class="relative inline-flex items-center cursor-pointer" title="Toggle AI Agent">
                                    <input type="checkbox" class="sr-only peer" {% if channel.ai_conversation_enabled %}checked{% endif %} onchange="toggleAI('{{ channel.id }}', this.checked)">
                                    <div class="w-11 h-6 bg-gray-200 dark:bg-dark-600 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-accent/30 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-accent"></div>
                                    <span class="ml-1.5 text-xs text-gray-500 dark:text-gray-400">AI</span>
                                </label>
                                <!-- Edit Button -->
                                <a href="/channel/{{ channel.id }}" class="p-2 text-gray-400 hover:text-gray-600 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-700 rounded-lg transition-colors">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
                                    </svg>
                                </a>
                                <!-- Delete Button -->
                                <button onclick="deleteChannel('{{ channel.id }}')" class="p-2 text-gray-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Vacancy Peek Section -->
                        <div class="p-3 sm:p-4" id="vacancy-peek-{{ channel.id }}">
                            <div class="flex items-center gap-2 mb-3">
                                <div class="flex rounded-lg bg-gray-100 dark:bg-dark-700 p-0.5 gap-0.5">
                                    <button class="px-2 sm:px-2.5 py-1 text-xs font-medium rounded-md sort-btn sort-btn-active" onclick="sortVacancies('latest', '{{ channel.id }}')" id="sort-latest-{{ channel.id }}">Latest</button>
                                    <button class="px-2 sm:px-2.5 py-1 text-xs font-medium rounded-md sort-btn sort-btn-inactive" onclick="sortVacancies('messages', '{{ channel.id }}')" id="sort-messages-{{ channel.id }}">Has msgs</button>
                                </div>
                            </div>

                            <!-- Vacancy Table -->
                            <div class="vacancy-peek-content max-h-80 overflow-auto rounded-lg" id="vacancy-content-{{ channel.id }}">
                                <div class="flex items-center justify-center py-6 text-sm text-gray-400">Loading...</div>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
                {% else %}
                <!-- Empty State -->
                <div class="flex flex-col items-center justify-center py-16 px-4">
                    <div class="flex items-center justify-center w-16 h-16 rounded-full bg-gray-100 dark:bg-dark-800 mb-4">
                        <svg class="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"/>
                        </svg>
                    </div>
                    <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-1">No channels yet</h3>
                    <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Create your first channel to start monitoring</p>
                    <a href="/channel/new" class="inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-accent rounded-lg hover:bg-accent-hover transition-all">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                        </svg>
                        Create Channel
                    </a>
                </div>
                {% endif %}
            </div>
        </main>
    </div>

    <!-- Global tooltip element -->
    <div id="vacancy-tooltip" class="vacancy-tooltip"></div>

    <!-- Vacancy Preview Modal -->
    <div id="vacancy-modal" class="fixed inset-0 z-50 hidden" onclick="closeVacancyModal(event)">
        <div class="absolute inset-0 bg-black/60 backdrop-blur-sm"></div>
        <div class="flex items-center justify-center min-h-full p-4">
            <div class="relative bg-white dark:bg-dark-800 rounded-xl shadow-xl max-w-2xl w-full max-h-[85vh] overflow-hidden dark:border dark:border-dark-700" onclick="event.stopPropagation()">
                <div class="flex items-center justify-between px-5 py-4 border-b border-gray-200 dark:border-dark-700">
                    <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Vacancy Details</h3>
                    <button onclick="closeVacancyModal()" class="p-1.5 text-gray-400 hover:text-gray-600 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-700 rounded-lg">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                    </button>
                </div>
                <div id="vacancy-modal-body" class="p-5 overflow-y-auto max-h-[calc(85vh-64px)]"></div>
            </div>
        </div>
    </div>

    <script>
        // Sidebar toggle
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            sidebar.classList.toggle('-translate-x-full');
            overlay.classList.toggle('hidden');
        }

        let peekVacancies = [];
        let currentSort = 'latest';
        let allVacancies = [];
        let activeTooltipIdx = null;
        let tooltipTimeout = null;

        // Get tooltip content based on type
        function getTooltipContent(v, type) {
            if (type === 'reason') {
                return v.ai_reason || (v.is_relevant ? 'Passed AI filter' : 'No reason provided');
            } else {
                const text = (v.text_full || v.text_preview || '').substring(0, 250);
                return text + (text.length >= 250 ? '...' : '');
            }
        }

        // Show tooltip on hover (desktop)
        function showTooltip(event, vacancyId, type = 'text') {
            if (window.innerWidth < 768) return; // Skip on mobile, use tap instead

            clearTimeout(tooltipTimeout);
            const v = peekVacancies.find(vac => vac.id === vacancyId);
            if (!v) return;

            const tooltip = document.getElementById('vacancy-tooltip');
            tooltip.textContent = getTooltipContent(v, type);

            // Position near the icon
            const rect = event.target.closest('.peek-icon').getBoundingClientRect();
            tooltip.style.left = Math.max(8, rect.left) + 'px';
            tooltip.style.top = (rect.bottom + 8) + 'px';
            tooltip.classList.add('show');
        }

        // Hide tooltip
        function hideTooltip() {
            tooltipTimeout = setTimeout(() => {
                const tooltip = document.getElementById('vacancy-tooltip');
                tooltip.classList.remove('show');
                activeTooltipIdx = null;
                activeTooltipType = null;
                document.querySelectorAll('.peek-icon').forEach(el => el.classList.remove('active'));
            }, 100);
        }

        let activeTooltipType = null;

        // Toggle tooltip on tap (mobile)
        function toggleTooltip(event, vacancyId, type = 'text') {
            const tooltip = document.getElementById('vacancy-tooltip');
            const tooltipKey = `${vacancyId}-${type}`;

            // If same tooltip is open, close it
            if (activeTooltipIdx === vacancyId && activeTooltipType === type && tooltip.classList.contains('show')) {
                hideTooltip();
                return;
            }

            // Close any open tooltip first
            document.querySelectorAll('.peek-icon').forEach(el => el.classList.remove('active'));

            const v = peekVacancies.find(vac => vac.id === vacancyId);
            if (!v) return;

            tooltip.textContent = getTooltipContent(v, type);

            // Position near the icon
            const rect = event.target.closest('.peek-icon').getBoundingClientRect();
            const tooltipWidth = Math.min(350, window.innerWidth * 0.9);
            let left = rect.left;
            if (left + tooltipWidth > window.innerWidth - 8) {
                left = window.innerWidth - tooltipWidth - 8;
            }
            tooltip.style.left = Math.max(8, left) + 'px';
            tooltip.style.top = (rect.bottom + 8) + 'px';
            tooltip.classList.add('show');

            event.target.closest('.peek-icon').classList.add('active');
            activeTooltipIdx = vacancyId;
            activeTooltipType = type;
        }

        // Close tooltip when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.peek-icon') && !e.target.closest('.vacancy-tooltip')) {
                hideTooltip();
            }
        });

        // Show vacancy preview modal (like /vacancy page)
        function showVacancyModal(vacancyId) {
            const v = peekVacancies.find(vac => vac.id === vacancyId);
            if (!v) return;

            const statusClass = v.is_relevant
                ? 'bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400'
                : 'bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400';
            const displayName = v.contact_name || (v.contact_username ? `@${v.contact_username}` : null) || v.chat_title || 'Unknown';

            document.getElementById('vacancy-modal-body').innerHTML = `
                <div class="space-y-4">
                    <div>
                        <label class="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">Source</label>
                        <p class="text-sm text-gray-900 dark:text-white mt-1">${escapeHtml(v.chat_title || 'Unknown')}</p>
                    </div>
                    <div>
                        <label class="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">Contact</label>
                        <p class="text-sm text-gray-900 dark:text-white mt-1">${escapeHtml(displayName)}</p>
                    </div>
                    <div>
                        <label class="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">Status</label>
                        <p class="mt-1">
                            <span class="px-2.5 py-1 text-xs font-medium rounded-full ${statusClass}">
                                ${v.is_relevant ? 'Passed' : 'Filtered'}
                            </span>
                        </p>
                    </div>
                    <div>
                        <label class="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">AI Reason</label>
                        <p class="text-sm text-gray-900 dark:text-gray-200 mt-1">${escapeHtml(v.ai_reason || 'No reason provided')}</p>
                    </div>
                    <div>
                        <label class="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">Processed</label>
                        <p class="text-sm text-gray-900 dark:text-gray-200 mt-1">${v.processed_at || '-'}</p>
                    </div>
                    <div>
                        <label class="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">Full Text</label>
                        <div class="mt-2 p-3 bg-gray-50 dark:bg-dark-900 rounded-lg text-sm text-gray-700 dark:text-gray-300 whitespace-pre-wrap max-h-64 overflow-y-auto">${escapeHtml(v.text_full || v.text_preview)}</div>
                    </div>
                </div>
            `;
            document.getElementById('vacancy-modal').classList.remove('hidden');
        }

        function closeVacancyModal(event) {
            if (event && event.target !== document.getElementById('vacancy-modal')) return;
            document.getElementById('vacancy-modal').classList.add('hidden');
        }

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeVacancyModal();
        });

        // Load status and update UI (uses cached fetch from cache.js)
        async function loadStatus() {
            loadCachedStatus((data) => {
                updateAllStatus(data);
                updateBotStatusIndicator(data);
            });
        }

        // Update bot status indicator on ALL channel cards
        function updateBotStatusIndicator(data) {
            if (!data || !data.success) return;

            const dots = document.querySelectorAll('.bot-status-dot');
            const texts = document.querySelectorAll('.bot-status-text');
            const indicators = document.querySelectorAll('.bot-status-indicator');

            const bot = data.status?.bot;
            const isLive = bot?.connected && bot?.authorized;

            dots.forEach(dot => {
                dot.className = isLive
                    ? 'bot-status-dot w-1.5 h-1.5 rounded-full bg-blue-500'
                    : 'bot-status-dot w-1.5 h-1.5 rounded-full bg-red-500';
            });

            texts.forEach(text => {
                text.textContent = isLive ? 'Live' : 'Offline';
            });

            indicators.forEach(indicator => {
                indicator.className = isLive
                    ? 'bot-status-indicator inline-flex items-center gap-1 px-2 py-0.5 text-xs rounded-full bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-400'
                    : 'bot-status-indicator inline-flex items-center gap-1 px-2 py-0.5 text-xs rounded-full bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400';
            });

            // Update agents count
            updateAgentsCountIndicator(data);
        }

        // Update agents running count on ALL channel cards
        function updateAgentsCountIndicator(data) {
            if (!data || !data.success) return;

            const texts = document.querySelectorAll('.agents-count-text');
            const indicators = document.querySelectorAll('.agents-count-indicator');

            const agents = data.status?.agents || {};
            let activeCount = 0;
            let totalCount = 0;

            for (const [name, agent] of Object.entries(agents)) {
                totalCount++;
                if (agent.status === 'connected' && !agent.flood_wait_until) {
                    activeCount++;
                }
            }

            const statusText = `${activeCount}/${totalCount} agents`;
            let indicatorClass;
            if (activeCount === 0) {
                indicatorClass = 'agents-count-indicator inline-flex items-center gap-1 px-2 py-0.5 text-xs rounded-full bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400';
            } else if (activeCount < totalCount) {
                indicatorClass = 'agents-count-indicator inline-flex items-center gap-1 px-2 py-0.5 text-xs rounded-full bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-400';
            } else {
                indicatorClass = 'agents-count-indicator inline-flex items-center gap-1 px-2 py-0.5 text-xs rounded-full bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400';
            }

            texts.forEach(text => {
                text.textContent = statusText;
            });

            indicators.forEach(indicator => {
                indicator.className = indicatorClass;
            });
        }

        // Toggle AI conversation on/off (auto-response and filtering stay active)
        async function toggleAI(channelId, enabled) {
            try {
                const response = await fetch(`/api/channels/${channelId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ai_conversation_enabled: enabled })
                });

                const data = await response.json();

                if (!data.success) {
                    alert('Error: ' + (data.message || 'Failed to update AI setting'));
                    const checkbox = document.querySelector(`[data-channel-id="${channelId}"] input[type="checkbox"]`);
                    checkbox.checked = !enabled;
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error updating AI setting');
                const checkbox = document.querySelector(`[data-channel-id="${channelId}"] input[type="checkbox"]`);
                checkbox.checked = !enabled;
            }
        }

        // Delete channel
        async function deleteChannel(channelId) {
            const deleteConfig = confirm('Delete this channel configuration?');
            if (!deleteConfig) return;

            const deleteTelegram = confirm('Also delete the Telegram channel and CRM group?\n\nClick OK to delete everything.\nClick Cancel to keep Telegram entities.');

            try {
                const response = await fetch(`/api/channels/${channelId}?delete_telegram=${deleteTelegram}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    let msg = 'Channel deleted!';
                    if (data.deleted && data.deleted.length > 0) {
                        msg += '\n\nDeleted: ' + data.deleted.join(', ');
                    }
                    if (data.pending && data.pending.length > 0) {
                        msg += '\n\nPending (rate limited): ' + data.pending.join(', ');
                    }
                    if (data.errors && data.errors.length > 0) {
                        msg += '\n\nErrors: ' + data.errors.join(', ');
                    }
                    alert(msg);
                    window.location.reload();
                } else {
                    alert('Error: ' + (data.message || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error deleting channel');
            }
        }

        // Load vacancy peek data (with caching)
        async function loadVacancyPeek() {
            loadCachedVacancies((data) => {
                if (data && data.success) {
                    allVacancies = data.vacancies;
                    renderVacancies();
                }
            }, 50);
        }

        // Per-channel sort state
        const channelSortState = {};

        function sortVacancies(sortBy, channelId) {
            // Update state for this channel
            channelSortState[channelId] = sortBy;

            // Update button styles for this channel only
            const latestBtn = document.getElementById(`sort-latest-${channelId}`);
            const messagesBtn = document.getElementById(`sort-messages-${channelId}`);

            if (sortBy === 'latest') {
                latestBtn.classList.remove('sort-btn-inactive');
                latestBtn.classList.add('sort-btn-active');
                messagesBtn.classList.remove('sort-btn-active');
                messagesBtn.classList.add('sort-btn-inactive');
            } else {
                messagesBtn.classList.remove('sort-btn-inactive');
                messagesBtn.classList.add('sort-btn-active');
                latestBtn.classList.remove('sort-btn-active');
                latestBtn.classList.add('sort-btn-inactive');
            }

            // Re-render only this channel
            renderChannelVacancies(channelId);
        }

        function renderVacancies() {
            // Render all channels
            document.querySelectorAll('[id^="vacancy-peek-"]').forEach(peek => {
                const channelId = peek.id.replace('vacancy-peek-', '');
                renderChannelVacancies(channelId);
            });
        }

        function renderChannelVacancies(channelId) {
            const sortBy = channelSortState[channelId] || 'latest';

            let sorted = [...allVacancies];
            if (sortBy === 'messages') {
                sorted.sort((a, b) => {
                    if (a.has_messages === b.has_messages) {
                        return new Date(b.processed_at) - new Date(a.processed_at);
                    }
                    return b.has_messages - a.has_messages;
                });
            } else {
                sorted.sort((a, b) => new Date(b.processed_at) - new Date(a.processed_at));
            }

            peekVacancies = sorted;

            // Render only this specific channel
            const card = document.querySelector(`[data-channel-id="${channelId}"]`);
            const sourceTitlesStr = card ? card.dataset.sourceTitles : '';
            const sourceTitles = sourceTitlesStr ? sourceTitlesStr.split('|||').map(t => t.toLowerCase()) : [];
            const contentContainer = document.getElementById(`vacancy-content-${channelId}`);

                // Filter vacancies by this channel's source titles
                // If no source titles mapped, show message instead of all vacancies
                if (sourceTitles.length === 0) {
                    contentContainer.innerHTML = '<div class="flex items-center justify-center py-6 text-sm text-gray-400 dark:text-gray-500">Sources not connected yet</div>';
                    return;
                }

                const channelVacancies = sorted.filter(v => {
                    const chatTitle = (v.chat_title || '').toLowerCase();
                    return sourceTitles.some(title => chatTitle === title.toLowerCase());
                });

                if (channelVacancies.length === 0) {
                    contentContainer.innerHTML = '<div class="flex items-center justify-center py-6 text-sm text-gray-400 dark:text-gray-500">No vacancies yet</div>';
                } else {
                    let html = `<table class="w-full text-sm">
                        <tbody class="divide-y divide-gray-100 dark:divide-dark-700">`;

                    channelVacancies.slice(0, 50).forEach((v) => {
                        const statusClass = v.is_relevant ? 'bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400' : 'bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400';
                        const statusLabel = v.is_relevant ? 'Passed' : getFilteredLabel(v.ai_reason);
                        const time = formatTime(v.processed_at);
                        // Show contact name if available, then username, then source channel
                        const displayName = v.contact_name || (v.contact_username ? `@${v.contact_username}` : null) || v.chat_title || 'Unknown';
                        const ledClass = v.has_messages ? 'bg-cyan-500' : 'bg-gray-300 dark:bg-dark-600';
                        // Tooltip text (first 250 chars)
                        const tooltipText = (v.text_full || v.text_preview || '').substring(0, 250);
                        const truncated = tooltipText.length >= 250 ? '...' : '';

                        // AI reason for status tooltip
                        const aiReason = v.ai_reason || (v.is_relevant ? 'Passed AI filter' : 'No reason provided');

                        html += `
                            <tr class="hover:bg-gray-100 dark:hover:bg-dark-700 active:bg-gray-200 dark:active:bg-dark-600 cursor-pointer transition-colors" onclick="openVacancyPage(${v.id})">
                                <td class="px-3 py-2">
                                    <span class="text-gray-700 dark:text-gray-300 truncate max-w-[120px] block">${escapeHtml(displayName)}</span>
                                </td>
                                <td class="px-3 py-2 text-right">
                                    <div class="flex items-center justify-end gap-1.5">
                                        <button class="peek-icon text-gray-400 dark:text-gray-500 p-1 hover:bg-gray-200 dark:hover:bg-dark-600 rounded" onclick="event.stopPropagation(); showVacancyModal(${v.id})" title="Preview">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                                            </svg>
                                        </button>
                                        <button class="peek-icon status-badge px-2 py-0.5 text-xs font-medium rounded-full ${statusClass}" onclick="event.stopPropagation(); toggleTooltip(event, ${v.id}, 'reason')" onmouseenter="showTooltip(event, ${v.id}, 'reason')" onmouseleave="hideTooltip()">${statusLabel}</button>
                                        <span class="w-1.5 h-1.5 rounded-full ${ledClass}"></span>
                                    </div>
                                </td>
                                <td class="px-3 py-2 text-right text-gray-500 dark:text-gray-400 text-xs whitespace-nowrap">${time}</td>
                            </tr>
                        `;
                    });

                html += '</tbody></table>';
                contentContainer.innerHTML = html;
            }
        }

        // Get short status label for filtered vacancies based on AI reason
        function getFilteredLabel(aiReason) {
            if (!aiReason) return 'Filtered';
            const reason = aiReason.toLowerCase();
            if (reason.includes('реклам') || reason.includes('advert') || reason.includes('promo')) return 'Ad';
            if (reason.includes('внешн') || reason.includes('external') || reason.includes('ссылк') || reason.includes('link')) return 'External';
            if (reason.includes('курс') || reason.includes('course') || reason.includes('обучен')) return 'Course';
            if (reason.includes('парт') || reason.includes('partner')) return 'Partner';
            if (reason.includes('не соответ') || reason.includes('not match') || reason.includes('не подход')) return 'No match';
            if (reason.includes('дубл') || reason.includes('duplic')) return 'Duplicate';
            if (reason.includes('старая') || reason.includes('old') || reason.includes('устар')) return 'Old';
            if (reason.includes('спам') || reason.includes('spam')) return 'Spam';
            if (reason.includes('не вакан') || reason.includes('not job') || reason.includes('not vacanc')) return 'Not a job';
            return 'Filtered';
        }

        // Navigate to full vacancy page
        function openVacancyPage(vacancyId) {
            // Pre-cache the vacancy data for instant load
            const vacancy = peekVacancies.find(v => v.id === vacancyId);
            if (vacancy) {
                AppCache.set(`vacancy_${vacancyId}`, { success: true, vacancy }, 60000);
                AppCache.set('recent_vacancies', peekVacancies, 30000);
            }
            window.location.href = `/vacancy/${vacancyId}`;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatTime(dateStr) {
            if (!dateStr) return '-';
            const date = new Date(dateStr + 'Z');
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        // Show cached data immediately on page load (before async calls)
        (function initFromCache() {
            // Cached agent status
            const cachedStatus = AppCache.get('status');
            if (cachedStatus) {
                updateAllStatus(cachedStatus);
                updateBotStatusIndicator(cachedStatus);
            }
            // Cached vacancies
            const cachedVacancies = AppCache.get('vacancies');
            if (cachedVacancies && cachedVacancies.success) {
                allVacancies = cachedVacancies.vacancies;
                renderVacancies();
            }
        })();

        // ===== Drag and Drop for Channel Cards =====
        let draggedCard = null;
        let draggedCardRect = null;

        function initDragAndDrop() {
            const container = document.getElementById('channels-container');
            if (!container) return;

            const cards = container.querySelectorAll('.channel-card');

            cards.forEach(card => {
                // Drag start
                card.addEventListener('dragstart', (e) => {
                    draggedCard = card;
                    draggedCardRect = card.getBoundingClientRect();
                    card.classList.add('opacity-50', 'scale-[0.98]');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', card.dataset.channelId);
                });

                // Drag end
                card.addEventListener('dragend', () => {
                    draggedCard.classList.remove('opacity-50', 'scale-[0.98]');
                    draggedCard = null;
                    // Remove all drop indicators
                    container.querySelectorAll('.channel-card').forEach(c => {
                        c.classList.remove('border-t-2', 'border-b-2', 'border-accent');
                    });
                });

                // Drag over
                card.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';

                    if (draggedCard === card) return;

                    // Determine if dropping above or below
                    const rect = card.getBoundingClientRect();
                    const midY = rect.top + rect.height / 2;

                    // Remove previous indicators
                    container.querySelectorAll('.channel-card').forEach(c => {
                        c.classList.remove('border-t-2', 'border-b-2', 'border-accent');
                    });

                    // Add indicator
                    if (e.clientY < midY) {
                        card.classList.add('border-t-2', 'border-accent');
                    } else {
                        card.classList.add('border-b-2', 'border-accent');
                    }
                });

                // Drag leave
                card.addEventListener('dragleave', () => {
                    card.classList.remove('border-t-2', 'border-b-2', 'border-accent');
                });

                // Drop
                card.addEventListener('drop', (e) => {
                    e.preventDefault();

                    if (draggedCard === card) return;

                    const rect = card.getBoundingClientRect();
                    const midY = rect.top + rect.height / 2;

                    // Insert before or after based on drop position
                    if (e.clientY < midY) {
                        container.insertBefore(draggedCard, card);
                    } else {
                        container.insertBefore(draggedCard, card.nextSibling);
                    }

                    // Save new order
                    saveChannelOrder();
                });
            });
        }

        async function saveChannelOrder() {
            const container = document.getElementById('channels-container');
            const cards = container.querySelectorAll('.channel-card');
            const order = Array.from(cards).map(card => card.dataset.channelId);

            try {
                const response = await fetch('/api/channels/reorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ order })
                });
                const data = await response.json();
                if (!data.success) {
                    console.error('Failed to save order:', data.message);
                }
            } catch (error) {
                console.error('Error saving channel order:', error);
            }
        }

        // Initialize drag and drop
        initDragAndDrop();

        // Load fresh data
        loadStatus();
        loadVacancyPeek();
        setInterval(loadStatus, 5000);
        setInterval(loadVacancyPeek, 30000);

        // Enable transitions after page load
        requestAnimationFrame(() => {
            document.body.classList.remove('preload');
        });
    </script>

    {% include 'partials/chat_widget.html' %}
</body>
</html>
